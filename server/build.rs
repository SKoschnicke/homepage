use std::fs::{self, File};
use std::io::Write as IoWrite;
use std::path::Path;
use flate2::write::GzEncoder;
use flate2::Compression;
use sha2::{Sha256, Digest};
use walkdir::WalkDir;

const PUBLIC_DIR: &str = "../public";
const OUTPUT: &str = "src/assets.rs";

fn main() {
    println!("cargo:rerun-if-changed={}", PUBLIC_DIR);

    // Check if public directory exists
    if !Path::new(PUBLIC_DIR).exists() {
        eprintln!("Warning: {} directory not found. Run 'hugo --minify' first.", PUBLIC_DIR);
        eprintln!("Creating empty assets.rs...");
        create_empty_assets();
        return;
    }

    let mut output = File::create(OUTPUT).expect("Failed to create assets.rs");

    // Write header
    writeln!(output, "// Auto-generated by build.rs - DO NOT EDIT").unwrap();
    writeln!(output, "#![allow(dead_code)]").unwrap();
    writeln!(output, "use std::collections::HashMap;\n").unwrap();

    // Write Asset struct (for HTTP/HTTPS)
    writeln!(output, "#[derive(Clone)]").unwrap();
    writeln!(output, "pub struct Asset {{").unwrap();
    writeln!(output, "    pub content_raw: &'static [u8],").unwrap();
    writeln!(output, "    pub content_gzip: &'static [u8],").unwrap();
    writeln!(output, "    pub content_brotli: &'static [u8],").unwrap();
    writeln!(output, "    pub content_type: &'static str,").unwrap();
    writeln!(output, "    pub etag: &'static str,").unwrap();
    writeln!(output, "    pub is_compressible: bool,").unwrap();
    writeln!(output, "}}\n").unwrap();

    // Write GeminiAsset struct (simpler - no compression needed)
    writeln!(output, "#[derive(Clone)]").unwrap();
    writeln!(output, "pub struct GeminiAsset {{").unwrap();
    writeln!(output, "    pub content: &'static [u8],").unwrap();
    writeln!(output, "    pub etag: &'static str,").unwrap();
    writeln!(output, "}}\n").unwrap();

    let mut http_routes = Vec::new();
    let mut gemini_routes = Vec::new();

    // Walk public/ directory - process both HTML and Gemini files
    for entry in WalkDir::new(PUBLIC_DIR).follow_links(true) {
        let entry = match entry {
            Ok(e) => e,
            Err(e) => {
                eprintln!("Warning: failed to read entry: {}", e);
                continue;
            }
        };

        if !entry.file_type().is_file() {
            continue;
        }

        let path = entry.path();
        let relative_path = path.strip_prefix(PUBLIC_DIR)
            .expect("Failed to strip prefix");

        // Check if this is a Gemini file
        let is_gemini = path.extension().map(|e| e == "gmi").unwrap_or(false);

        // Read file content
        let content = match fs::read(path) {
            Ok(c) => c,
            Err(e) => {
                eprintln!("Warning: failed to read {}: {}", path.display(), e);
                continue;
            }
        };

        // Generate ETag (SHA256 hash of content)
        let mut hasher = Sha256::new();
        hasher.update(&content);
        let etag = format!("{:x}", hasher.finalize());

        if is_gemini {
            // Process as Gemini asset
            let path_str = relative_path.to_string_lossy().replace('\\', "/");

            // Convert path to Gemini route:
            // - /index.gmi -> /
            // - /about/index.gmi -> /about/
            // - /posts/hello-world/index.gmi -> /posts/hello-world/
            let route = if path_str == "index.gmi" {
                "/".to_string()
            } else if path_str.ends_with("/index.gmi") {
                format!("/{}", path_str.trim_end_matches("index.gmi"))
            } else {
                // Non-index .gmi file (shouldn't happen with Hugo, but handle it)
                format!("/{}", path_str.trim_end_matches(".gmi"))
            };

            let ident = format!("GEMINI{}", sanitize_ident(&route));

            // Write content const
            writeln!(output, "const CONTENT_{}: &[u8] = &{:?};", ident, content).unwrap();

            // Write GeminiAsset const
            writeln!(output, "const ASSET_{}: GeminiAsset = GeminiAsset {{", ident).unwrap();
            writeln!(output, "    content: CONTENT_{},", ident).unwrap();
            writeln!(output, "    etag: \"{}\",", etag).unwrap();
            writeln!(output, "}};\n").unwrap();

            gemini_routes.push((route, ident));
        } else {
            // Process as HTTP asset
            let route = format!("/{}", relative_path.to_string_lossy())
                .replace('\\', "/");

            // Detect content type
            let content_type = mime_guess::from_path(path)
                .first_or_octet_stream()
                .as_ref()
                .to_string();

            // Determine if content should be compressed
            let is_compressible = is_compressible_type(&content_type);

            // Compress if beneficial
            let (gzip_content, brotli_content) = if is_compressible {
                (compress_gzip(&content), compress_brotli(&content))
            } else {
                (content.clone(), content.clone())
            };

            let ident = sanitize_ident(&route);

            // Write raw content
            writeln!(output, "const CONTENT_RAW_{}: &[u8] = &{:?};", ident, content).unwrap();

            // Only write different compressed versions if actually compressible
            if is_compressible {
                writeln!(output, "const CONTENT_GZIP_{}: &[u8] = &{:?};", ident, gzip_content).unwrap();
                writeln!(output, "const CONTENT_BROTLI_{}: &[u8] = &{:?};", ident, brotli_content).unwrap();
            } else {
                writeln!(output, "const CONTENT_GZIP_{}: &[u8] = CONTENT_RAW_{};", ident, ident).unwrap();
                writeln!(output, "const CONTENT_BROTLI_{}: &[u8] = CONTENT_RAW_{};", ident, ident).unwrap();
            }

            // Write Asset const
            writeln!(output, "const ASSET_{}: Asset = Asset {{", ident).unwrap();
            writeln!(output, "    content_raw: CONTENT_RAW_{},", ident).unwrap();
            writeln!(output, "    content_gzip: CONTENT_GZIP_{},", ident).unwrap();
            writeln!(output, "    content_brotli: CONTENT_BROTLI_{},", ident).unwrap();
            writeln!(output, "    content_type: \"{}\",", content_type).unwrap();
            writeln!(output, "    etag: \"{}\",", etag).unwrap();
            writeln!(output, "    is_compressible: {},", is_compressible).unwrap();
            writeln!(output, "}};\n").unwrap();

            http_routes.push((route, ident));
        }
    }

    // Generate get_routes function (HTTP)
    writeln!(output, "pub fn get_routes() -> HashMap<&'static str, &'static Asset> {{").unwrap();
    writeln!(output, "    let mut m = HashMap::new();").unwrap();
    for (route, ident) in &http_routes {
        writeln!(output, "    m.insert(\"{}\", &ASSET_{});", route, ident).unwrap();
    }
    writeln!(output, "    m").unwrap();
    writeln!(output, "}}\n").unwrap();

    // Generate get_gemini_routes function
    writeln!(output, "pub fn get_gemini_routes() -> HashMap<&'static str, &'static GeminiAsset> {{").unwrap();
    writeln!(output, "    let mut m = HashMap::new();").unwrap();
    for (route, ident) in &gemini_routes {
        writeln!(output, "    m.insert(\"{}\", &ASSET_{});", route, ident).unwrap();
    }
    writeln!(output, "    m").unwrap();
    writeln!(output, "}}").unwrap();

    println!("cargo:warning=Generated {} HTTP routes", http_routes.len());
    println!("cargo:warning=Generated {} Gemini routes", gemini_routes.len());
}

fn is_compressible_type(mime: &str) -> bool {
    mime.starts_with("text/")
        || mime.contains("javascript")
        || mime.contains("json")
        || mime.contains("xml")
        || mime.contains("svg")
}

fn compress_gzip(data: &[u8]) -> Vec<u8> {
    let mut encoder = GzEncoder::new(Vec::new(), Compression::best());
    encoder.write_all(data).expect("Failed to compress with gzip");
    encoder.finish().expect("Failed to finish gzip compression")
}

fn compress_brotli(data: &[u8]) -> Vec<u8> {
    let mut output = Vec::new();
    let params = brotli::enc::BrotliEncoderParams {
        quality: 11,
        ..Default::default()
    };
    let mut input = &data[..];
    brotli::BrotliCompress(&mut input, &mut output, &params)
        .expect("Failed to compress with brotli");
    output
}

fn sanitize_ident(path: &str) -> String {
    path.chars()
        .map(|c| if c.is_alphanumeric() { c.to_ascii_uppercase() } else { '_' })
        .collect()
}

fn create_empty_assets() {
    let mut output = File::create(OUTPUT).expect("Failed to create assets.rs");
    writeln!(output, "// Empty assets - run 'hugo --minify' first").unwrap();
    writeln!(output, "use std::collections::HashMap;\n").unwrap();
    writeln!(output, "#[derive(Clone)]").unwrap();
    writeln!(output, "pub struct Asset {{").unwrap();
    writeln!(output, "    pub content_raw: &'static [u8],").unwrap();
    writeln!(output, "    pub content_gzip: &'static [u8],").unwrap();
    writeln!(output, "    pub content_brotli: &'static [u8],").unwrap();
    writeln!(output, "    pub content_type: &'static str,").unwrap();
    writeln!(output, "    pub etag: &'static str,").unwrap();
    writeln!(output, "    pub is_compressible: bool,").unwrap();
    writeln!(output, "}}\n").unwrap();
    writeln!(output, "#[derive(Clone)]").unwrap();
    writeln!(output, "pub struct GeminiAsset {{").unwrap();
    writeln!(output, "    pub content: &'static [u8],").unwrap();
    writeln!(output, "    pub etag: &'static str,").unwrap();
    writeln!(output, "}}\n").unwrap();
    writeln!(output, "pub fn get_routes() -> HashMap<&'static str, &'static Asset> {{").unwrap();
    writeln!(output, "    HashMap::new()").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output, "pub fn get_gemini_routes() -> HashMap<&'static str, &'static GeminiAsset> {{").unwrap();
    writeln!(output, "    HashMap::new()").unwrap();
    writeln!(output, "}}").unwrap();
}
