use std::fs::{self, File};
use std::io::Write as IoWrite;
use std::path::Path;
use flate2::write::GzEncoder;
use flate2::Compression;
use sha2::{Sha256, Digest};
use walkdir::WalkDir;

const PUBLIC_DIR: &str = "../public";
const OUTPUT: &str = "src/assets.rs";

fn main() {
    println!("cargo:rerun-if-changed={}", PUBLIC_DIR);

    // Check if public directory exists
    if !Path::new(PUBLIC_DIR).exists() {
        eprintln!("Warning: {} directory not found. Run 'hugo --minify' first.", PUBLIC_DIR);
        eprintln!("Creating empty assets.rs...");
        create_empty_assets();
        return;
    }

    let mut output = File::create(OUTPUT).expect("Failed to create assets.rs");

    // Write header
    writeln!(output, "// Auto-generated by build.rs - DO NOT EDIT").unwrap();
    writeln!(output, "#![allow(dead_code)]").unwrap();
    writeln!(output, "use std::collections::HashMap;\n").unwrap();

    // Write Asset struct
    writeln!(output, "#[derive(Clone)]").unwrap();
    writeln!(output, "pub struct Asset {{").unwrap();
    writeln!(output, "    pub content_raw: &'static [u8],").unwrap();
    writeln!(output, "    pub content_gzip: &'static [u8],").unwrap();
    writeln!(output, "    pub content_brotli: &'static [u8],").unwrap();
    writeln!(output, "    pub content_type: &'static str,").unwrap();
    writeln!(output, "    pub etag: &'static str,").unwrap();
    writeln!(output, "    pub is_compressible: bool,").unwrap();
    writeln!(output, "}}\n").unwrap();

    let mut routes = Vec::new();

    // Walk public/ directory
    for entry in WalkDir::new(PUBLIC_DIR).follow_links(true) {
        let entry = match entry {
            Ok(e) => e,
            Err(e) => {
                eprintln!("Warning: failed to read entry: {}", e);
                continue;
            }
        };

        if !entry.file_type().is_file() {
            continue;
        }

        let path = entry.path();
        let relative_path = path.strip_prefix(PUBLIC_DIR)
            .expect("Failed to strip prefix");

        let route = format!("/{}", relative_path.to_string_lossy())
            .replace('\\', "/");

        // Read file content
        let content = match fs::read(path) {
            Ok(c) => c,
            Err(e) => {
                eprintln!("Warning: failed to read {}: {}", path.display(), e);
                continue;
            }
        };

        // Detect content type
        let content_type = mime_guess::from_path(path)
            .first_or_octet_stream()
            .as_ref()
            .to_string();

        // Generate ETag (SHA256 hash of content)
        let mut hasher = Sha256::new();
        hasher.update(&content);
        let etag = format!("{:x}", hasher.finalize());

        // Determine if content should be compressed
        let is_compressible = is_compressible_type(&content_type);

        // Compress if beneficial
        let (gzip_content, brotli_content) = if is_compressible {
            (compress_gzip(&content), compress_brotli(&content))
        } else {
            // For non-compressible content, just reference the same data
            (content.clone(), content.clone())
        };

        // Generate const identifier
        let ident = sanitize_ident(&route);

        // Write raw content
        writeln!(output, "const CONTENT_RAW_{}: &[u8] = &{:?};", ident, content).unwrap();

        // Only write different compressed versions if actually compressible
        if is_compressible {
            writeln!(output, "const CONTENT_GZIP_{}: &[u8] = &{:?};", ident, gzip_content).unwrap();
            writeln!(output, "const CONTENT_BROTLI_{}: &[u8] = &{:?};", ident, brotli_content).unwrap();
        } else {
            writeln!(output, "const CONTENT_GZIP_{}: &[u8] = CONTENT_RAW_{};", ident, ident).unwrap();
            writeln!(output, "const CONTENT_BROTLI_{}: &[u8] = CONTENT_RAW_{};", ident, ident).unwrap();
        }

        // Write Asset const
        writeln!(output, "const ASSET_{}: Asset = Asset {{", ident).unwrap();
        writeln!(output, "    content_raw: CONTENT_RAW_{},", ident).unwrap();
        writeln!(output, "    content_gzip: CONTENT_GZIP_{},", ident).unwrap();
        writeln!(output, "    content_brotli: CONTENT_BROTLI_{},", ident).unwrap();
        writeln!(output, "    content_type: \"{}\",", content_type).unwrap();
        writeln!(output, "    etag: \"{}\",", etag).unwrap();
        writeln!(output, "    is_compressible: {},", is_compressible).unwrap();
        writeln!(output, "}};\n").unwrap();

        routes.push((route, ident));
    }

    // Generate get_routes function
    writeln!(output, "pub fn get_routes() -> HashMap<&'static str, &'static Asset> {{").unwrap();
    writeln!(output, "    let mut m = HashMap::new();").unwrap();

    for (route, ident) in &routes {
        writeln!(output, "    m.insert(\"{}\", &ASSET_{});", route, ident).unwrap();
    }

    writeln!(output, "    m").unwrap();
    writeln!(output, "}}").unwrap();

    println!("cargo:warning=Generated {} routes", routes.len());
}

fn is_compressible_type(mime: &str) -> bool {
    mime.starts_with("text/")
        || mime.contains("javascript")
        || mime.contains("json")
        || mime.contains("xml")
        || mime.contains("svg")
}

fn compress_gzip(data: &[u8]) -> Vec<u8> {
    let mut encoder = GzEncoder::new(Vec::new(), Compression::best());
    encoder.write_all(data).expect("Failed to compress with gzip");
    encoder.finish().expect("Failed to finish gzip compression")
}

fn compress_brotli(data: &[u8]) -> Vec<u8> {
    let mut output = Vec::new();
    let params = brotli::enc::BrotliEncoderParams {
        quality: 11, // Max quality for static assets
        ..Default::default()
    };
    let mut input = &data[..];
    brotli::BrotliCompress(&mut input, &mut output, &params)
        .expect("Failed to compress with brotli");
    output
}

fn sanitize_ident(path: &str) -> String {
    path.chars()
        .map(|c| if c.is_alphanumeric() { c.to_ascii_uppercase() } else { '_' })
        .collect()
}

fn create_empty_assets() {
    let mut output = File::create(OUTPUT).expect("Failed to create assets.rs");
    writeln!(output, "// Empty assets - run 'hugo --minify' first").unwrap();
    writeln!(output, "use std::collections::HashMap;\n").unwrap();
    writeln!(output, "#[derive(Clone)]").unwrap();
    writeln!(output, "pub struct Asset {{").unwrap();
    writeln!(output, "    pub content_raw: &'static [u8],").unwrap();
    writeln!(output, "    pub content_gzip: &'static [u8],").unwrap();
    writeln!(output, "    pub content_brotli: &'static [u8],").unwrap();
    writeln!(output, "    pub content_type: &'static str,").unwrap();
    writeln!(output, "    pub etag: &'static str,").unwrap();
    writeln!(output, "    pub is_compressible: bool,").unwrap();
    writeln!(output, "}}\n").unwrap();
    writeln!(output, "pub fn get_routes() -> HashMap<&'static str, &'static Asset> {{").unwrap();
    writeln!(output, "    HashMap::new()").unwrap();
    writeln!(output, "}}").unwrap();
}
